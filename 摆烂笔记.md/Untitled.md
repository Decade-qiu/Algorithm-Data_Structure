# 软件设计模式

软件模式是将模式的一般概念应用于软件开发领域，是软件开发的总体指导思路和参照样板。软件模式并非仅局限于设计模式，还包括：架构模式、分析模式和过程模式等。

设计模式（Design Pattern），是解决特定问题的一系列套路；是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案；**是一套经验总结**。

设计模式本质是面向对象设计原则的实际运用，是对类的封装性、继承性、多态性，以及类的关联关系和组合关系的充分理解。
设计模式主要有三大类型：创建型模式、结构型模式、行为型模式；

**创建型设计模式**：描述对象如何创建，是为了将对象的创建与使用分离。包括五种：单例、原型、工厂方法、抽象工厂、建造者。

**结构型模式**：描述类或对象如何组织成更大结构，包括7种：代理、适配器、桥接、装饰、外观、享元、组合。

**行为型模式**：描述类或对象之间如何协作完成任务，包括11种：模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。

**UML**

类图和时序图

类之间的关系：

依赖关系（Dependency）、关联（A|ssociation）、聚合（Aggregation）、组合（Composition）、泛化关系（Generalization）、实现（Realization）。

**七种设计原则：**

耦合性、稳定性、风险、可读性、可维护性；

**开闭原则（OCP**）：对扩展开放，对修改关闭；通过抽象约束、封装变化实现；使用接口或抽象类实现；

**里氏替换原则（LSP）**：阐述继承复用的原则；开闭原则实现方式；子类继承父类时，尽量不要重写父类方法；（不要破坏继承关系）

**依赖倒置原则（DIP）**：面向接口编程，不要面向实现编程；实现开闭原则的重要途径之一，降低了客户与实现模块间的耦合。

**单一职责原则（SRP）**：类实现职责要单一；控制类的粒度、将对象解耦、提高内聚性；注重职责，主要约束类（实现和细节）；

**接口隔离原则（ISP）**：建立专用接口，提高内聚性，降低耦合性；注重对接口依赖的隔离，主要约束接口（抽象和框架）；

**迪米特法则（LoD）**：最少知识原则（LKP），降低耦合性；只和朋友交谈，不和陌生人说话；通过中介类，增加系统复杂性；

**合成复用原则（CRP）**：组合/聚合复用原则（CARP），优先使用组合或聚合关系实现复用，少用继承关系来实现；





**创建型模式**



创建型模式（Creational Pattern），对类的实例化过程进行了抽象，将对象的创建和使用分离。单一职责原则；降低系统耦合度，使用者不需要关注对象创建细节，由相关工厂来完成；



**单例模式（Singleton）**：

单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例，提供全局访问的方法。



![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-a475c8696f59bb06a428785ac539a272_b.jpg)







![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-8f2f7123629b084e3dc79f7e411629f8_r.jpg)



单例模式通常有两种实现方式：

**饿汉式单例**：类加载时就创建了单例；


**懒汉式单例**：类加载时不生成单例，第一次调用时才创建单例；多线程时，注意 volatile 和 synchronized 保证线程安全；


优缺点：没有抽象层，扩展困难；职责过重，违背单一职责原则；垃圾回收导致对象状态丢失；




**原型模式（Prototype）**：
用于创建重复的对象，同时又能保证性能。提供了一种创建对象的最佳方法。


可以使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一摸一样的对象；

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-e508dbecc57c71c369bae2f385182491_b.jpg)





原型模式，的克隆分为浅克隆和深克隆；Java 实现 Cloneable 接口用 Object 提供的 clone() 方法实现浅克隆；

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-4dd1e7f65e7391125b6922bde0124aeb_b.jpg)






**工程方法模式（FactoryMethod）**：


定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中。满足创建与使用相分离；



![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-9cb4fbe364c148c511a8bdd64f7884d0_b.jpg)





![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-6fde2b04235f29ffd8abaddba2b45734_r.jpg)


**抽象工厂（AbstractFactory）**：
抽象工厂模式，是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构；


抽象工厂模式，是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品；

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-924f95340ec68d1ed203e0508ad5261a_b.jpg)






包含角色：抽象工厂、具体工厂、抽象产品、具体产品；

![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-8d5f63a4dad0bb8a401c2f04549a1982_r.jpg)




**建造者模式（Builder）**：
建造者模式，指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示；







![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-5bc64e2ecdfcd0100f6cf59112fe4c58_b.jpg)





![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-917c0a209bde04fab5068b78ccf70504_r.jpg)


Computer computer=new Computer.Builder("因特尔","三星")
.setDisplay("三星24寸")
.setKeyboard("罗技")
.setUsbCount(2)
.build();


**结构型模式**


结构型模式（Structural Pattern），关注如何将现有类或对象组织在一起，形成更加强大的结构；


可分为两种：类结构模式和对象结构模式；前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象；组合聚合关系比继承关系耦合度低，满足合成复用原则，所以对象结构型模式具有更大的灵活性。




**适配器模式（Adaptor）**：


将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。


适配器模式分为：类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高；


**典型应用场景**：新旧系统兼容适配；第三方接口适配；电源转换适配器；
通过适配器模式可以将三方库的接口转换成目前系统设计的接口，而不需要大规模修改目前的系统；
通过设计适配器接口，可以兼容相同功能的不同实现方案；


类适配器模式：

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-e03c768b5ed2989d4afa2f420d918d63_b.jpg)






对象适配器模式

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-11eb2060d33ad872b66531d64a3d5dba_b.jpg)








**代理模式（Proxy）**：
封装目标对象，并限制外界对目标对象的访问。
在客户端和目标对象之间，引入一个代理中介，控制对目标对象的访问；
**典型应用场景**：AOP，面向切面编程，注入代码
注意区分装饰者模式和代理模式的区别；



![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-eb9933a8360e4235841ce690f51a1f9d_b.jpg)






应用场景：
远程代理、虚拟代理、安全代理、智能指引、延迟加载


**桥接模式（Bridge）**：
将抽象与实现分离，使它们可以独立变化。用组合关系代替继承关系实现，从而降低抽象和实现的耦合度；


**典型应用场景**：解决类的多维度变化问题；（可以将继承的指数复杂度，降为组合的线性复杂度）；**产业分工**就是典型的桥接模式，从以前的国企大包干，转变为产业协同发展，每个企业只负责产业链上某个部分；设计公司，将产业链上不同企业的产品**组合式创新**，形成新的产品；




桥接模式，将类的不同属性，按照属性维度拆分到不同的类中，每个类负责一个属性的变化。

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-6dc3b0ba7e517edce62637901ad32214_b.jpg)









![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-24531b52e3b22ddf1240d923d130938a_b.jpg)






适配器、桥接模式、外观模式之间关系
桥接模式，可用于逻辑与实现的分离，一般在设计的前期；
适配器模式，用于第三方实现适配，一般在设计的后期；

![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-8fb113a4ecf08257f2592c5569b0385d_r.jpg)








**装饰模式（Decorator）**：


在不改变现有对象结构的情况下，动态地给对象增加一些额外功能（职责）；

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-e522782edd431352b249572452ec36f6_b.jpg)







![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-f4eb971677120c5a3f2002189d9f11dc_r.jpg)




**外观模式（Facade）**：


对外提供一个统一的接口；迪米特法则的典型应用，降低耦合度，屏蔽了子系统组建；


**典型应用场景**：微服务的网关，API Gateway ；



![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-2b18b79a43bf9c80007d9430c28e5960_b.jpg)





![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-f5b192fff603c4f6e3dfe0df560b9392_r.jpg)






**享元模式（Flyweight）**：
享元模式是池技术的重要实现方式；
运用共享技术来有效支持大量细粒度对象的复用；避免大量对象的创建开销，提高系统资源利用率；

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-91006685188648038a4b67258300259d_b.jpg)







![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-dfdbb3cc339093823adb0daae490fde8_r.jpg)





单纯享元和复合享元模式；


**组合模式（Composite）**：
也叫部分-整体模式，将对象组合成树状的层次结构的模式，用来表示部分-整体关系，使用户对单个对象和组合对象具有一致的访问性；


分为透明式和安全式的组合模式；
透明式：

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-44c5f1708c950ea16871b8d91315d0ea_b.jpg)






安全式：

![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-309758370d93e9b6bb603e6c304076a2_b.jpg)










**行为型模式**


行为型模式，用于描述程序在运行时复杂的流程控制；

描述多个类或对象之间，如何相互协作共同完成单个对象无法完成的任务；涉及算法与对象间职责的分配；



行为型模式可分为：类行为模式和对象行为模式，前者采用继承机制来实现类间分派行为，后者采用组合或聚合在对象间分配行为。



模板方法模式和解释器模式是类行为模式；



**模板方法模式（Template Method）**：

定义操作的算法骨架，而将一些步骤延迟到子类，使得子类可在不改变算法结构的情况下，重定义算法的某些特定步骤；



封装固定部分，扩展可变部分；符合开闭原则；



*类似可编程渲染管线；管线流程固定，着色器可编程扩展；*







![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-855c2dc3718792b4e2c738edd0fe73e2_b.jpg)









**策略模式（Strategy）：**



定义策略接口，不同的实现类提供不同的具体策略算法，同时它们之间可以互相替换。

通过对算法封装，把使用算法的责任和实现分割开来，并委派给不同的对象进行管理；



使用策略模式：可以避免使用多重条件语句；通过提供可复用算法，避免重复的代码；提供相同行为的不同实现；



灵活组织算法；





![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-cfd20802e8a2c3c3e536c0ea60961798_b.jpg)









**命令模式（Command）**：

将一个请求封装成一个对象，使发出请求的责任和执行请求的责任分隔开。请求者和实现者，通过命令对象进行沟通，方便将命令对象进程储存、传递、调用、增加和管理；



*类似于消息通信，通过消息管道（命令接口），来将消息发送给接收方处理*







![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-284c0e86a16a5b751ff72c75c8a5175e_b.jpg)











![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-a425c56be4a12e8d1ace61472ef903b8_r.jpg)





**责任链模式（Chain of Responsibility）**：





通过数据链表实现责任链模式；

*类似Pipeline 模式实现，DAG 和Blender 节点编程*





![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-c6735f6dbd38582f4defa430f390977c_b.jpg)







![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-eeb3163883409208fb292a0497d110ec_b.jpg)











**状态模式（State）**：

对有状态的对象，把复杂的判断逻辑提取到不同的状态对象种，允许状态对象在其内部状态发生改变时，改变其行为；



*类似状态机机制，包括有限状态机和层次状态机；线程状态切换机制；*





![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-9b1dd329d342ba4dd429602b9216a2ac_b.jpg)









![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-c142ae6d8b9a188ac80bc7a089d4800a_b.jpg)







![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-a61a69dc272c322353adbaecb4855f71_b.jpg)







**观察者模式（Observer）**：



定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象，在状态发生变化时，会通知所有观察者；



*接口回调，响应式编程 RxJava，订阅通知机制；*

Observable 和 Observer





![动图封面](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-c37ffc881963363837dadfff710b998f_b.jpg)







![img](../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E5%BA%93/v2-3c48e6a827531f4acce41d7aebf3e8f3_r.jpg)
